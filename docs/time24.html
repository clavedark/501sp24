<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dave Clark">
<meta name="dcterms.date" content="2024-04-09">

<title>PLSC 501 - Spring 2024 - Time and Variance in the OLS model</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">PLSC 501 - Spring 2024</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./slides.html"> 
<span class="menu-text">Slides</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./syllabus24.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./code.html"> 
<span class="menu-text">Code</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Time and Variance in the OLS model</h1>
                      </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author">Dave Clark </p>
    </div>
    <div class="quarto-title-meta-contents">
          <p class="affiliation">
              Binghamton University
            </p>
        </div>
    </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 9, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#time-and-variance" id="toc-time-and-variance" class="nav-link active" data-scroll-target="#time-and-variance">Time and Variance</a>
  <ul class="collapse">
  <li><a href="#assumptions" id="toc-assumptions" class="nav-link" data-scroll-target="#assumptions">Assumptions</a></li>
  </ul></li>
  <li><a href="#time" id="toc-time" class="nav-link" data-scroll-target="#time">Time</a>
  <ul class="collapse">
  <li><a href="#uncorrelated-disturbances" id="toc-uncorrelated-disturbances" class="nav-link" data-scroll-target="#uncorrelated-disturbances">Uncorrelated Disturbances</a></li>
  <li><a href="#temporal-correlation" id="toc-temporal-correlation" class="nav-link" data-scroll-target="#temporal-correlation">Temporal correlation</a></li>
  <li><a href="#autoregressive-processes" id="toc-autoregressive-processes" class="nav-link" data-scroll-target="#autoregressive-processes">Autoregressive Processes</a></li>
  <li><a href="#variance-covariance-matrix-of-widehatbeta" id="toc-variance-covariance-matrix-of-widehatbeta" class="nav-link" data-scroll-target="#variance-covariance-matrix-of-widehatbeta">Variance-Covariance matrix of <span class="math inline">\(\widehat{\beta}\)</span></a></li>
  <li><a href="#detecting-autocorrelation" id="toc-detecting-autocorrelation" class="nav-link" data-scroll-target="#detecting-autocorrelation">Detecting Autocorrelation</a></li>
  <li><a href="#graphical-methods---using-state-murder-rate-data" id="toc-graphical-methods---using-state-murder-rate-data" class="nav-link" data-scroll-target="#graphical-methods---using-state-murder-rate-data">Graphical Methods - using state murder rate data</a></li>
  <li><a href="#regression-based-detection" id="toc-regression-based-detection" class="nav-link" data-scroll-target="#regression-based-detection">Regression-based detection</a></li>
  <li><a href="#regression-based-methods" id="toc-regression-based-methods" class="nav-link" data-scroll-target="#regression-based-methods">Regression based methods</a>
  <ul class="collapse">
  <li><a href="#durbin-watson-d-statistic" id="toc-durbin-watson-d-statistic" class="nav-link" data-scroll-target="#durbin-watson-d-statistic">Durbin-Watson <em>d</em> Statistic</a></li>
  <li><a href="#breusch-godfrey-lm-test" id="toc-breusch-godfrey-lm-test" class="nav-link" data-scroll-target="#breusch-godfrey-lm-test">Breusch-Godfrey LM Test</a></li>
  <li><a href="#wooldridge-test-for-panel-data" id="toc-wooldridge-test-for-panel-data" class="nav-link" data-scroll-target="#wooldridge-test-for-panel-data">Wooldridge test for panel data</a></li>
  </ul></li>
  <li><a href="#correcting-ar1-processes" id="toc-correcting-ar1-processes" class="nav-link" data-scroll-target="#correcting-ar1-processes">Correcting AR(1) processes</a></li>
  <li><a href="#rho-transformations" id="toc-rho-transformations" class="nav-link" data-scroll-target="#rho-transformations"><span class="math inline">\(\rho\)</span>-transformations</a></li>
  <li><a href="#dynamic-models" id="toc-dynamic-models" class="nav-link" data-scroll-target="#dynamic-models">Dynamic Models</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<!-- render 2 types at same time; terminal "quarto render file.qmd" -->
<!-- https://quarto.org/docs/output-formats/html-multi-format.html -->
<!-- tables, smaller font and striping -->
<style>
table, th, td {
    font-size: 18px;
}
tr:nth-child(odd) {
  background-color: # f2f2f2;
}
</style>
<!-- <script src="https://cdn.jsdelivr.net/gh/ncase/nutshell/nutshell.js"></script> -->
<section id="time-and-variance" class="level1">
<h1>Time and Variance</h1>
<p>Our discussion of panel data emphasized the space and time dimensions and what the consequences of heterogeneity might be. Those dimensions may also have characteristics that violate the OLS assumptions so we can no longer rely on the BLUE properties of the estimator.</p>
<section id="assumptions" class="level2">
<h2 class="anchored" data-anchor-id="assumptions">Assumptions</h2>
<p>Recall these assumptions:</p>
<p>This one holds that cross sections will have <em>identically</em> distributed disturbances.</p>
<p><strong>Homoskedastic disturbances:</strong> <span class="math inline">\(Var(u|x_1,x_2,\ldots,x_k)=\sigma^2\)</span></p>
<p>And this one holds that the disturbances will be <em>independent</em>.</p>
<p><strong>Uncorrelated disturbances:</strong> <span class="math inline">\(cov(u_i,u_j|x_1,x_2,\ldots,x_k)=0\)</span></p>
<p>Let’s call these collectively the i.i.d. assumption.</p>
</section>
</section>
<section id="time" class="level1">
<h1>Time</h1>
<section id="uncorrelated-disturbances" class="level2">
<h2 class="anchored" data-anchor-id="uncorrelated-disturbances">Uncorrelated Disturbances</h2>
<p>The model assumes the errors are not correlated with each other such that:</p>
<p><span class="math display">\[cov(u_t, u_{t-k} = 0)\]</span></p>
<p>the errors are not correlated across time;</p>
<p>and</p>
<p><span class="math display">\[cov(u_i, u_j = 0)\]</span> the errors are not correlated across units or cross-sections (so across space).</p>
<p>You should be able to see why the first can be an issue in time series data, the second in cross-sectional data, and both in panel data.</p>
</section>
<section id="temporal-correlation" class="level2">
<h2 class="anchored" data-anchor-id="temporal-correlation">Temporal correlation</h2>
<p>The nature of temporal correlations varies hugely. The focus of most basic time series analysis is autocorrelation - the error is correlated with itself at some point in the past so that,</p>
<p><span class="math display">\[
cov[u_t,u_{t-k}] \neq 0,  \nonumber
\]</span></p>
<p>Because the errors are not independent, and because we know the rough source of their dependency, we could conceive of <span class="math inline">\(u_t\)</span> as\</p>
<p><span class="math display">\[
u_t= \rho u_{t-1} + \varepsilon_t  ~~~\forall t, ~~~-1 &lt; \rho &lt; 1
\]</span></p>
<p>where the error at <span class="math inline">\(t\)</span> is a function of the error at <span class="math inline">\(t-1\)</span> and <span class="math inline">\(\rho\)</span> is the coefficient indicating the effect of <span class="math inline">\(u_{t-1}\)</span> on <span class="math inline">\(u_t\)</span>.</p>
<p>This conceptualization of <span class="math inline">\(u_t\)</span> is known as a <strong>first order autoregressive process</strong> or AR(1) because we’ve assumed <span class="math inline">\(u_t\)</span> is a function of <span class="math inline">\(u_{t-1}\)</span> rather than some other order or lag of <span class="math inline">\(u\)</span>; note we could just as easily model higher order lags as AR(t) functions.</p>
<p>Also note the inclusion of an error term, <span class="math inline">\(\varepsilon_t\)</span> satisfying the GM assumptions, so:</p>
<p><span class="math display">\[
E[\varepsilon_t] =0 \nonumber \nonumber \\
Var(\varepsilon_t)= \sigma^2 \nonumber \nonumber \\
Cov(\varepsilon_t, \varepsilon_{t-k})=0
\]</span></p>
</section>
<section id="autoregressive-processes" class="level2">
<h2 class="anchored" data-anchor-id="autoregressive-processes">Autoregressive Processes</h2>
<p>Let’s think about the errors <span class="math inline">\(u_t\)</span> for all <span class="math inline">\(t\)</span> in the AR scheme:</p>
<p><span class="math display">\[\begin{align*}
u_t= \rho u_{t-1} + \varepsilon_t
= \rho(\rho u_{t-2} +\varepsilon_{t-1}) + \varepsilon_t  \nonumber \\
= \rho^2 u_{t-2} + \rho \varepsilon_{t-1} + \varepsilon_t  \nonumber \\
= \rho^2(\rho u_{t-3} + \varepsilon_{t-2}) + \rho \varepsilon_{t-1}+ \varepsilon_t  \nonumber \\
= \rho^3 u_{t-3} + \rho^2 \varepsilon_{t-2} + \rho \varepsilon_{t-1}+ \varepsilon_t  \nonumber \\
\vdots \nonumber \\
= \rho^s u_{t-s} + \rho^{s-1} \varepsilon_{t-s+1} + \rho^{s-2} \varepsilon_{t-s+2}+ \ldots + \rho \varepsilon_{t-1} + \varepsilon_t  \nonumber \\ \nonumber \\
u_t= \sum \limits_{s=0}^{\infty} \rho^s u_{t-s}
\end{align*}\]</span></p>
<p>You can see the effect of the lagged residuals up to <span class="math inline">\(s\)</span> on <span class="math inline">\(u_t\)</span>; since <span class="math inline">\(|\rho| &lt; 1\)</span>, then <span class="math inline">\(|\rho^2| &lt; |\rho|\)</span>, and so forth, so the effect of each successive lag (<span class="math inline">\(t-2, t-3, \ldots, t-s\)</span>) is smaller than the previous lag, eventually decaying to zero.</p>
</section>
<section id="variance-covariance-matrix-of-widehatbeta" class="level2">
<h2 class="anchored" data-anchor-id="variance-covariance-matrix-of-widehatbeta">Variance-Covariance matrix of <span class="math inline">\(\widehat{\beta}\)</span></h2>
<p>If the errors are correlated, then the variance-covariance matrix is certain to be troubled by that correlation if it is not corrected. In fact,</p>
<p><span class="math display">\[\begin{align*}
Var(u_t)= \frac{\sigma^2}{1-\rho^2} \\
Cov(u_t, u_{t-1})= \rho \sigma^2 \\
Cov(u_t, u_{t-2})= \rho^2 \sigma^2 \\
Cov(u_t, u_{t-3})= \rho^3 \sigma^2 \\
\vdots \\
Cov(u_t, u_{t-s})= \rho^s \sigma^2 \\
\end{align*}\]</span></p>
<p>so it’s easy to see that if <span class="math inline">\(\rho=0\)</span>, then:</p>
<p><span class="math display">\[
u_t= \varepsilon_t \nonumber \\
Var(u_t)= \sigma_\varepsilon^2 \nonumber \\
cov(u_{t}, u_{t-k})=0 \nonumber
\]</span></p>
<p>If <span class="math inline">\(\rho \neq 0\)</span> the OLS estimator is not BLUE; even though the estimates are unbiased, they are inefficient, so the standard errors are not based on minimum variance in the class of estimators.</p>
</section>
<section id="detecting-autocorrelation" class="level2">
<h2 class="anchored" data-anchor-id="detecting-autocorrelation">Detecting Autocorrelation</h2>
<p>We’ll focus on two approaches:</p>
<ul>
<li><p>graphical methods.</p></li>
<li><p>regression-based methods.</p></li>
</ul>
</section>
<section id="graphical-methods---using-state-murder-rate-data" class="level2">
<h2 class="anchored" data-anchor-id="graphical-methods---using-state-murder-rate-data">Graphical Methods - using state murder rate data</h2>
<div class="cell" data-layout-align="center">
<details class="code-fold">
<summary>code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>states <span class="ot">&lt;-</span> <span class="fu">read_dta</span>(<span class="st">"/Users/dave/Documents/teaching/501/2023/slides/L8_panel/code/USstatedata.dta"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>ms <span class="ot">&lt;-</span> <span class="fu">lm</span>(murder <span class="sc">~</span> south <span class="sc">+</span> unemp <span class="sc">+</span> hsdip <span class="sc">+</span> citid <span class="sc">+</span> prcapinc, <span class="at">data=</span>states)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#summary(ms)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>states <span class="ot">&lt;-</span> states <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(<span class="at">res=</span><span class="fu">residuals</span>(ms))  </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>states <span class="ot">&lt;-</span> states <span class="sc">%&gt;%</span> <span class="fu">group_by</span>(id) <span class="sc">%&gt;%</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">res1=</span>dplyr<span class="sc">::</span><span class="fu">lag</span>(res,<span class="dv">1</span>), <span class="at">res2=</span>dplyr<span class="sc">::</span><span class="fu">lag</span>(res,<span class="at">n=</span><span class="dv">2</span>), <span class="at">res3=</span>dplyr<span class="sc">::</span><span class="fu">lag</span>(res,<span class="at">n=</span><span class="dv">3</span>))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>statesxs <span class="ot">&lt;-</span> states <span class="sc">%&gt;%</span> <span class="fu">group_by</span>(statename) <span class="sc">%&gt;%</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(<span class="fu">across</span>(<span class="fu">c</span>(murder,res, res1, res2, res3), mean, <span class="at">na.rm=</span><span class="cn">TRUE</span>))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># ggplot(statesxs, aes(x=res_mean, y=murder_mean))+</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_point()</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(states, <span class="fu">aes</span>(<span class="at">x=</span>res, <span class="at">y=</span>murder))<span class="sc">+</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="time24_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
<details class="code-fold">
<summary>code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data=</span>statesxs, <span class="fu">aes</span>(<span class="at">x=</span>res, <span class="at">y=</span>res1),<span class="at">color=</span><span class="st">"red"</span>)<span class="sc">+</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data=</span>statesxs, <span class="fu">aes</span>(<span class="at">x=</span>res, <span class="at">y=</span>res2), <span class="at">color=</span><span class="st">"blue"</span>)<span class="sc">+</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">geom_point</span>(<span class="at">data=</span>statesxs, <span class="fu">aes</span>(<span class="at">x=</span>res, <span class="at">y=</span>res3), <span class="at">color=</span><span class="st">"yellow"</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="time24_files/figure-html/unnamed-chunk-1-2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
<p>In both cases (simulated, state murder rate data), the panels suggest the residuals are not random across time. The left panel plots the residuals against their lag and indicates the relationship between <span class="math inline">\(u_t, u_{t-1}\)</span>; the right panel shows a relationship between the residuals and time, and it’s pretty clearly not random. So let’s turn to some more mechanical ways of detecting autocorrelation.</p>
</section>
<section id="regression-based-detection" class="level2">
<h2 class="anchored" data-anchor-id="regression-based-detection">Regression-based detection</h2>
<p>Write the autocorrelation function:</p>
<p><span class="math display">\[\begin{eqnarray}
u_t= \rho u_{t-1} + \varepsilon_t  ~~~\forall t, ~~~-1 &lt; \rho &lt; 1
\nonumber
\end{eqnarray}\]</span></p>
<p>We can estimate this <em>auxiliary regression</em> using the residuals and their lagged values. The coefficient on <span class="math inline">\(u_{t-1}\)</span> is our estimate <span class="math inline">\(\hat{\rho}\)</span>.</p>
</section>
<section id="regression-based-methods" class="level2">
<h2 class="anchored" data-anchor-id="regression-based-methods">Regression based methods</h2>
<p>We’ll look at three regression based methods:</p>
<ul>
<li>Durbin-Watson</li>
<li>Breusch-Godfrey</li>
<li>Wooldridge</li>
</ul>
<p>All three rely on estimating the OLS model, generating the residuals, and examining the relationships among different lags of the residuals for evidence of correlation.</p>
<p>The DW <em>d</em> is specifically designed for time-series data with exclusively exogenous variables in the model. In other words, models with lagged endogenous variables cannot be appropriately diagnosed using DW’s <em>d</em>. Instead, you should use Durbin and Watson’s <em>h</em> statistic or the BG Lagrange Multiplier test.</p>
<p>This is maybe the simplest regression-based way to detect autocorrelation:</p>
<ul>
<li>estimate the regression of interest</li>
<li>generate the residuals</li>
<li>regress the residuals on its lag (or lags)</li>
<li>if the coefficient on the lagged residuals is different from zero, some sort of AR process exists.</li>
</ul>
<section id="durbin-watson-d-statistic" class="level3">
<h3 class="anchored" data-anchor-id="durbin-watson-d-statistic">Durbin-Watson <em>d</em> Statistic</h3>
<p>The <em>d</em> statistic tests a variety of null hypotheses, all supposing no AR(1) process exists. It has limited application because of the assumptions on which it’s based:</p>
<ul>
<li>the regression includes an intercept.</li>
<li>the <span class="math inline">\(x\)</span> variables are fixed.</li>
<li>the errors are AR(1)</li>
<li>the model has no lagged endogenous variables.</li>
<li>there are no missing observations in the time series.</li>
</ul>
<p>Beyond these limitations, the statistic has a bizarre distribution for which DW computed upper and lower bounds (outside of which we reject the null of no autocorrelation), but in the middle of which there is a region known as the “indeterminate” zone or “zone of indecision.”</p>
<p>Here’s how the statistic is computed:</p>
<p><span class="math display">\[
d= \frac{\sum \hat{u}_{t}^{2} + \sum \hat{u}_{t-1}^{2} -2 \sum
\hat{u}_{t}\hat{u}_{t-1}}{\sum \hat{u}_{t}^{2}} \nonumber
\]</span></p>
<p>Because the residuals and lagged residuals differ by one observation, they are not equal, but are approximately equal, so we can set them equal and write:</p>
<p><span class="math display">\[
d= 2  \left( 1- \frac{\sum \hat{u}_{t}\hat{u}_{t-1}}{\sum
\hat{u}_{t}^{2}} \right) \nonumber
\]</span></p>
<p>The last term of this equation is <span class="math inline">\(\rho\)</span> - you can see the numerator is the covariation of the residuals and their lag, and the denominator is the sum squared residuals; this is a correlation coefficient indicating the correlation between <span class="math inline">\(u_t, u_{t-1}\)</span>.</p>
<p><span class="math display">\[
\rho =  \frac{\sum \hat{u}_{t}\hat{u}_{t-1}}{\sum \hat{u}_{t}^{2}}
\]</span></p>
<p>Consistent with the restrictions/assumptions underlying this statistic, note that we’ve estimated <span class="math inline">\(\rho_{1}\)</span> and so only can test for an AR(1) process. Given our estimate of <span class="math inline">\(\rho\)</span>, we can compute <em>d</em> as</p>
<p><span class="math display">\[
d= 2(1-\hat{\rho})  \nonumber
\]</span></p>
<p>And since <span class="math inline">\(\rho\)</span> is bounded by -1 and +1, <em>d</em> must be bounded by 0 and 4.</p>
<p>Here are the criteria for evaluating Durbin-Watson statistics:</p>
</section>
<section id="breusch-godfrey-lm-test" class="level3">
<h3 class="anchored" data-anchor-id="breusch-godfrey-lm-test">Breusch-Godfrey LM Test</h3>
<p>The BG test is a more general test because it can account for higher order AR processes (while DW is limited to AR(1)). Moreover, the BG test is simple to compute by hand and has few of the limitations listed above for DW. \alert{Note, this is not appropriate for panel data.</p>
<p>Here’s how it works:</p>
<ul>
<li>Estimate the OLS regression model.</li>
<li>Generate the residuals.</li>
<li>Regress the residuals, <span class="math inline">\(\hat{u}_t\)</span>, on all the <span class="math inline">\(x\)</span> variables in the model plus as many lagged values of <span class="math inline">\(\hat{u}_t\)</span> as you want to test, so; <span class="math inline">\(\hat{u}_{t-1}\)</span>, <span class="math inline">\(\hat{u}_{t-2}\)</span>, <span class="math inline">\(\hat{u}_{t-3}\)</span>, <span class="math inline">\(\hat{u}_{t-p}\)</span> etc.</li>
</ul>
<p>In this example, we’re testing 3 lags, so <span class="math inline">\(p=3\)</span>. The regression would be:</p>
<p><span class="math display">\[
\hat{u}_t= X\beta+\rho_1 \hat{u}_{t-1} +\rho_2 \hat{u}_{t-2}+\rho_3
\hat{u}_{t-3} \nonumber
\]</span></p>
<p>Using the <span class="math inline">\(R^2\)</span> from this auxiliary regression, generate the BG LM statistic as:</p>
<p><span class="math display">\[
(n-p) R^2 ~~ \sim \chi_p^2
\]</span></p>
<p>The BG is a <span class="math inline">\(\chi_p^2\)</span> statistic with <span class="math inline">\(p\)</span> degrees of freedom. The null hypothesis is that <span class="math inline">\(\rho_1=\rho_2=\rho_3=0\)</span>. The BG test not only allows testing for higher order AR processes, but can be used in models with lagged endogenous variables as well.</p>
</section>
<section id="wooldridge-test-for-panel-data" class="level3">
<h3 class="anchored" data-anchor-id="wooldridge-test-for-panel-data">Wooldridge test for panel data</h3>
<p>Wooldridge’s test is simple; note that it’s appropriate for panel data as well.</p>
<ul>
<li>difference all variables; estimate the differenced regression, clustered by panel, excluding a constant.</li>
<li>generate the residuals from this regression.</li>
<li>regress the residuals on their lag, no constant, clustered by panel.</li>
<li>test the null hypothesis that <span class="math inline">\(\beta\)</span> on the lag of the residual is equal to -.5.</li>
</ul>
</section>
</section>
<section id="correcting-ar1-processes" class="level2">
<h2 class="anchored" data-anchor-id="correcting-ar1-processes">Correcting AR(1) processes</h2>
<p>Most methods for dealing with autocorrelation seek to purge the temporal dependence from the data by transforming the data.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Generalized Least Squares">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Generalized Least Squares
</div>
</div>
<div class="callout-body-container callout-body">
<p>Generalized Least Squares: OLS on data transformed such that the data satisfy the assumptions of the OLS model.</p>
</div>
</div>
<p>One common GLS method for dealing with correlated errors is to estimate <span class="math inline">\(\rho\)</span>-transformed models - two common variants are the Prais-Winsten and Cochrane-Orcutt regressions.</p>
</section>
<section id="rho-transformations" class="level2">
<h2 class="anchored" data-anchor-id="rho-transformations"><span class="math inline">\(\rho\)</span>-transformations</h2>
<p>The intuition of <span class="math inline">\(\rho\)</span>-transformed models is simple:</p>
<ul>
<li>estimate the regression of interest.</li>
<li>generate the residuals.</li>
<li>estimate <span class="math inline">\(\hat{\rho}\)</span> as above.</li>
<li>transform the variables by <span class="math inline">\(\rho\)</span> such that: <span class="math display">\[y_t - \rho y_{t-1} = \beta_0(1-\rho)+ \beta_1(x_{1,t} - \rho x_{1,t-1}) \ldots\]</span></li>
<li>call the new transformed variables <span class="math inline">\(y^*, x^*\)</span></li>
<li>estimate the regression <span class="math inline">\(y^*=\beta^*_0+\beta^*_1(x^*)\)</span></li>
</ul>
<p>This particular process is the Cochrane-Orcutt 2-step method. Others are similar. The estimates are now corrected by the estimated value of <span class="math inline">\(\rho\)</span>.</p>
</section>
<section id="dynamic-models" class="level2">
<h2 class="anchored" data-anchor-id="dynamic-models">Dynamic Models</h2>
<p>Lagging <span class="math inline">\(y_t\)</span> and including it on the right hand side of the regression equation can ameliorate autocorrelation, but it changes the interpretation of the coefficients (all of them).</p>
<p>Lagging <span class="math inline">\(y_t\)</span> is powerful - it generally is a poor choice for dealing with autocorrelation, but a great choice for estimating long term effects - these are known as <em>dynamic models</em>.</p>
<p>Lagging <span class="math inline">\(x\)</span> variables is also a great choice if theory implies the effect of <span class="math inline">\(x\)</span> is spread over time, and accumulates in some fashion - these models are known as <em>distributed lag models</em>.</p>
<p>Dynamic models allow us to examine the long-term effects of changes in <span class="math inline">\(x\)</span> on <span class="math inline">\(y_t\)</span>. The equation we estimate is</p>
<p><span class="math display">\[
y_t=+ \gamma y_{t-1}+ \beta_{0}+\beta_{1}X_{1} + \beta_{2}X_{2} \ldots +  \beta_{k}X_{k}
\]</span></p>
<p>where the first term estimates the “memory” in the <span class="math inline">\(y\)</span>-series. That is, it measures how much the present value of <span class="math inline">\(y\)</span> is a function of remembering the value of <span class="math inline">\(y\)</span> at <span class="math inline">\(t-1\)</span>. Thinking of <span class="math inline">\(-1 &lt;\gamma&lt; 1\)</span>, as <span class="math inline">\(|\gamma|\)</span> increases, so does memory.</p>
<p>What does it mean for these lag-models to be dynamic? In the OLS setting, <span class="math inline">\(x\)</span> has a <span class="math inline">\(\beta\)</span> effect on <span class="math inline">\(y\)</span>. In this setting, if <span class="math inline">\(x_t\)</span> has a <span class="math inline">\(\beta\)</span> effect on <span class="math inline">\(y_t\)</span>, and if <span class="math inline">\(\gamma \neq 0\)</span>, then <span class="math inline">\(x_t\)</span> also has some effect on <span class="math inline">\(y_{t+1}\)</span>. In other words, the determinants of <span class="math inline">\(y\)</span> also exhibit a sort of memory-like, accumulating effect on future values of <span class="math inline">\(y\)</span>.</p>
<p>What these models permit is measurement of short term effects - <span class="math inline">\(\beta_k\)</span>; and long term effects <span class="math inline">\(\frac{\beta_k}{1-\gamma}\)</span>.</p>
<p>Why not use lags of <span class="math inline">\(y\)</span> to deal with autocorrelation? The AR problem is that <span class="math inline">\(u_t\)</span> is correlated with <span class="math inline">\(u_{t-1}\)</span>. In the dynamic setting, if these observations on the error are correlated, they must also be correlated with <span class="math inline">\(y_{t-1}\)</span> - this is a big problem because now, one of the regressors is correlated with <span class="math inline">\(u\)</span> - an endogeneity-like problem. Whereas AR usually causes inefficiency alone, in the dynamic model it also produces biased estimates.</p>
<p>For this reason, it’s inadvisable to use a lag strategy to deal with AR. It’s also advisable to test for AR in dynamic models, and to use AR methods (like Prais-Winsten) to deal with AR problems in dynamic models.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div id="refs" role="list">

</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>